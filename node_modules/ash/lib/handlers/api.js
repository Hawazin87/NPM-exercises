// (The MIT License)

// Copyright (c) 2012 Richard S Allinson <rsa@mountainmansoftware.com>

// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// 'Software'), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:

// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/*global define: true*/

"use strict";

var count = 0;

define(["lib/utils"], function (utils) {

    function inferredTmplModule(module) {
        return module.split("/").slice(0, -1).join("/") + "/tmpls";
    }

    function makeResponseMeta(data, meta, request) {

        var module = request.module,
            method = request.method,
            responseMeta = {
                uuid: utils.uuidv4(),
                data: meta,
                tmpl: {
                    module: null,
                    name: null
                },
                view: {
                    module: null,
                    name: null
                }
            };

        /*
            Do not change this code without running all tests
        */

        if (typeof data === "object") {
            if (!meta) {
                responseMeta.tmpl.module = inferredTmplModule(module);
                responseMeta.tmpl.name = method;
            } else if (typeof meta === "string") {
                responseMeta.tmpl.module = inferredTmplModule(module);
                responseMeta.tmpl.name = meta;
            } else if (typeof meta === "object") {
                if (meta.tmpl.module) {
                    responseMeta.tmpl.module = meta.tmpl.module;
                } else {
                    responseMeta.tmpl.module = inferredTmplModule(module);
                }
                if (typeof meta.tmpl === "string") {
                    responseMeta.tmpl.name = meta.tmpl;
                } else if (meta.tmpl.name) {
                    responseMeta.tmpl.name = meta.tmpl.name;
                } else {
                    responseMeta.tmpl.name = method;
                }
            }
        }

        if (responseMeta.tmpl.name && responseMeta.tmpl.name[0] === ".") {
            responseMeta.tmpl.module = "lib/helpers/render";
            responseMeta.tmpl.name = responseMeta.tmpl.name.slice(1);
        }

        // And before we return make the "responseMeta" object immutable
        Object.freeze(responseMeta);

        return responseMeta;
    }

    return function (request, response, dispatcher) {

        /*
            api = {
                done: response.done,
                flush: response.flush,
                dispatch: dispatcher,
                use: {}
            };
        */
        return {

            done: function (data, meta) {
                this.flush(data, meta);
                response.done();
                // Stop call timer (see lib/responses/dispatcher.js for start)
                utils.timer(request.module + "." + request.method + ":call");
            },

            flush: function (data, meta) {

                var responseMeta;

                // Before ANYTHING else happens make the "meta" object immutable
                if (typeof meta === "object") {
                    Object.freeze(meta);
                }

                responseMeta = makeResponseMeta(data, meta, request);

                if (responseMeta.tmpl.module) {
                    // get template and render data here
                    require(["lib/helpers/render"], function (render) {
                        if (responseMeta.tmpl.module === "lib/helpers/render") {
                            render[responseMeta.tmpl.name](data, function (str) {
                                response.flush(str, responseMeta);
                            });
                        } else {
                            render.tmpl(data, responseMeta.tmpl.module, responseMeta.tmpl.name, function (str) {
                                response.flush(str, responseMeta);
                            });
                        }
                    });
                } else {
                    response.flush(data, responseMeta);
                }
            },

            dispatch: dispatcher,

            use: {}
        };
    };
});