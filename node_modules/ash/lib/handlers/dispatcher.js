// (The MIT License)

// Copyright (c) 2012 Richard S Allinson <rsa@mountainmansoftware.com>

// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// 'Software'), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:

// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/*global define: true*/

"use strict";

define(["lib/handlers/api", "lib/utils"], function (apiFactory, utils) {

    return {

        /*
            The one and only dispatch function.

            request = {
                module: "",
                method: "",
                inputs: {}
            };

            response = {
                done: function (data, meta){
                    // Adapter to runtime
                },
                flush: function (data, meta) {
                    // Adapter to runtime
                }
            };
        */
        dispatch: function (request, response) {

            var self = this,
                module,
                method,
                inputs,
                api;

            // Before ANYTHING else happens make the "request" object immutable
            Object.freeze(request);

            // Before we do anything reset the global timer
            utils.timer("timer:reset");

            module = request.module;
            method = request.method;
            inputs = request.inputs;

            if (!module || !method) {
                throw new Error("The arguments [module] and [method] must have string values");
            }

            if (!response) {
                throw new Error("The argument [response] must have a value of a response object");
            }

            if (!inputs) {
                inputs = {};
            }

            if (typeof inputs !== "object") {
                throw new Error("The argument [inputs] can only have a value of an object");
            }

            // Start "dispatch" timer (see below for stop)
            utils.timer(module + "." + method + ":dispatch");

            // Take the request/response we were given and return an API object
            api = apiFactory(request, response, this.dispatch);

            // Before we can do anyhting we have to require the module
            require([module], function (object) {

                var ctrl,
                    helper,
                    helpers = [];

                // Create an instance of the contoller
                ctrl = Object.create(object);

                // Make sure the helpers attribute is an array
                if (!ctrl.helpers) {
                    ctrl.helpers = [];
                }

                // Get the list of helpers the module is requesting
                for (helper in ctrl.helpers) {
                    if (ctrl.helpers.hasOwnProperty(helper)) {
                        // Convert the short names into module names
                        helpers.push("lib/helpers/" + ctrl.helpers[helper]);
                    }
                }

                // With a complete module list we can now require them
                require(helpers, function () {
                    var helperId;
                    // Attach each helper in the requested order
                    for (helperId in ctrl.helpers) {
                        if (ctrl.helpers.hasOwnProperty(helperId)) {
                            // Each helper is attached using its short name
                            api.use[ctrl.helpers[helperId]] = Object.create(arguments[helperId]);
                            // If the helper has a init() function call it
                            if (typeof api.use[ctrl.helpers[helperId]].init === "function") {
                                api.use[ctrl.helpers[helperId]].init(request, response, api);
                            }
                        }
                    }
                    // Stop  "dispatch" timer (see above for start)
                    utils.timer(module + "." + method + ":dispatch");
                    // Star "call" timer (see lib/responses/template.js for stop)
                    utils.timer(module + "." + method + ":call");
                    // Finally "call" the method requested
                    try {
                        ctrl[method](api);
                    } catch (err) {
                        // TODO: Come back to this error message.
                        console.log(err);
                        api.done(err, {error: true, tmpl: ".raw"});
                    }
                });
            }, function (err) {

                var proxyRequest = {
                        module: "lib/handlers/proxy",
                        method: "execute",
                        inputs: {
                            body: request
                        }
                    };

                if (request.module === proxyRequest.module) {
                    console.log(JSON.stringify(proxyRequest, null, 4));
                    throw new Error("No more rabit hole.");
                }

                // If we didn't find the module try the "lib/handlers/proxy" module
                self.dispatch(proxyRequest, response);
            });
        }
    };
});